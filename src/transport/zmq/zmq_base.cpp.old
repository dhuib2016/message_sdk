#include "zmq_base.h"

#include <chrono>

namespace msgsdk {

ZmqBase::ZmqBase(const ClientConfig& cfg)
    : config_(cfg),
      context_(),
      workers_(cfg.worker_threads) {
}

ZmqBase::~ZmqBase() {
    stop();
}

bool ZmqBase::start() {

    if (running_) return true;

    socket_ = std::make_unique<zmqpp::socket>(
        context_, socketType());

    setupSocket(*socket_);

    // 连接
    // socket_->connect(config_.endpoint);
    // connect 只给客户端用
    if (socketType() == zmqpp::socket_type::req ||
        socketType() == zmqpp::socket_type::sub ||
        socketType() == zmqpp::socket_type::push) {

        socket_->connect(config_.endpoint);
        // 等待连接建立（REQ socket 需要）
        if (socketType() == zmqpp::socket_type::req) {
            std::this_thread::sleep_for(std::chrono::milliseconds(100));
        }
    }

    workers_.start();

    running_ = true;

    // 对于 REQ socket，不需要 ioLoop（发送和接收都在 onSend 中同步完成）
    if (socketType() != zmqpp::socket_type::req) {
        io_thread_ = std::thread(
            &ZmqBase::ioLoop, this);
    }

    std::thread(&ZmqBase::dispatchLoop, this).detach();

    return true;
}

void ZmqBase::stop() {

    if (!running_) return;

    running_ = false;

    recv_queue_.stop();
    send_queue_.stop();  // 也要停止发送队列

    workers_.stop();

    if (io_thread_.joinable())
        io_thread_.join();

    if (socket_) {
        socket_->close();
        socket_.reset();
    }
}

bool ZmqBase::isRunning() const {
    return running_;
}

void ZmqBase::setupSocket(zmqpp::socket& sock) {

    // 对于 REQ socket，receive_timeout 应该设为 -1（无限等待）
    // 因为 REQ socket 发送后必须阻塞等待回复
    if (socketType() == zmqpp::socket_type::req) {
        sock.set(zmqpp::socket_option::receive_timeout, -1);  // 无限等待
        //sock.set(zmqpp::socket_option::identity, "ZMQ"); 
    } else {
        sock.set(zmqpp::socket_option::receive_timeout,
                 config_.recv_timeout);
    }

    sock.set(zmqpp::socket_option::send_timeout,
             config_.send_timeout);

    sock.set(zmqpp::socket_option::send_high_water_mark,
             config_.send_hwm);

    sock.set(zmqpp::socket_option::receive_high_water_mark,
             config_.recv_hwm);
}

void ZmqBase::handleRawMessage(zmqpp::message& msg)
{
    // 默认什么都不做
    (void)msg;
}

void ZmqBase::ioLoop() {

    zmqpp::poller poller;
    poller.add(*socket_);

    while (running_) {
        // 对于 REQ socket，发送和接收都在 onSend() 中同步完成
        // ioLoop 只需要处理接收队列的分发
        if (socketType() == zmqpp::socket_type::req) {
            // REQ socket 的发送已经在 onSend() 中同步完成
            // 这里只需要短暂休眠，等待 onSend() 被调用
            std::this_thread::sleep_for(std::chrono::milliseconds(5));
        } else {
            // 非 REQ socket：处理发送队列
            Message send_msg;
            if (send_queue_.tryPop(send_msg)) {
                std::lock_guard<std::mutex> lock(socket_mutex_);
                try {
                    auto now = std::chrono::steady_clock::now();
                    auto timestamp = std::chrono::duration_cast<std::chrono::microseconds>(
                        now.time_since_epoch()).count();
                    {
                        std::lock_guard<std::mutex> log_lock(msgsdk::get_log_mutex());
                        std::cout << "===== [send queue process] ts=" << timestamp << " us" << std::flush << std::endl;
                    }

                    zmqpp::message zmsg;
                    encode(send_msg, zmsg);
                    socket_->send(zmsg);
                } catch (const zmqpp::zmq_internal_exception& e) {
                    std::cerr << "Send error: " << e.what() << std::endl;
                }
            }

            // 使用 poller 接收消息
            if (poller.poll(5)) {
                if (poller.has_input(*socket_)) {
                    std::lock_guard<std::mutex> lock(socket_mutex_);
                    zmqpp::message msg;
                    bool ok = socket_->receive(msg);

                    if (ok) {
                        // not use thread pool performace is better
                        // Benchmark: sending 10000 requests...
                        // Total time for 10000 calls: 3446 ms, avg: 344.6 us/call
                        Message m;
                        if (decode(msg, m)) {
                            //handler_(m);
                            auto now = std::chrono::steady_clock::now();
                            auto timestamp = std::chrono::duration_cast<std::chrono::microseconds>(
                                now.time_since_epoch()).count();
                            {
                                std::lock_guard<std::mutex> log_lock(msgsdk::get_log_mutex());
                                std::cout << "===== [recv queue push] ts=" << timestamp << " us" << std::flush << std::endl;
                            }
                            recv_queue_.push(m);
                        }
                    }
                }
            }
        }
    }
}

void ZmqBase::dispatchLoop() {

    while (running_) {

        Message msg;

        if (!recv_queue_.pop(msg))
            break;

        if (handler_) {
            auto now = std::chrono::steady_clock::now();
            auto timestamp = std::chrono::duration_cast<std::chrono::microseconds>(
                now.time_since_epoch()).count();
            {
                std::lock_guard<std::mutex> log_lock(msgsdk::get_log_mutex());
                std::cout << "[handler real start] ts=" << timestamp << " us" << std::flush << std::endl;
            }
            handler_(msg);
            // workers_.post([=] {
            //     handler_(msg);
            // });
        }
    }
}

bool ZmqBase::decode(zmqpp::message& zmsg,
                           Message& msg) {

    try {
        //std::cout << "Parts: " << zmsg.parts() << std::endl;
        if (zmsg.parts()==2){
            zmsg >> msg.topic >> msg.payload;
        } else {
            zmsg >> msg.payload;
        }
        
        return true;
    }
    catch (...) {
        return false;
    }
}

void ZmqBase::encode(const Message& msg,
                           zmqpp::message& zmsg) {

    zmsg << msg.topic << msg.payload;
    //zmsg << msg.payload;
}

void ZmqBase::onSend(const Message& msg) {
    // 对于 REQ socket，直接同步发送和接收
    if (socketType() == zmqpp::socket_type::req) {
        std::lock_guard<std::mutex> lock(socket_mutex_);
        
        try {
            if (!socket_) {
                std::cerr << "REQ socket is null" << std::endl;
                return;
            }

            // 发送请求
            zmqpp::message zmsg;
            encode(msg, zmsg);
            socket_->send(zmsg);

            //zmqpp::message request;
            //request << "Hello";
            //socket_->send(request);
            
            // 立即接收回复（阻塞，因为 receive_timeout 已设为 -1）
            zmqpp::message reply;
            bool received = socket_->receive(reply);
            if (received) {
                Message m;
                if (decode(reply, m)) {
                    handler_(m);
                    //recv_queue_.push(m);
                }
            }
        } catch (const zmqpp::zmq_internal_exception& e) {
            std::cerr << "REQ socket error: " << e.what() << std::endl;
        }
    } else {
        // 其他 socket 类型使用队列
        std::cout << "send queue ...>>>>" << std::endl;
        send_queue_.push(msg);
    }
}

}

